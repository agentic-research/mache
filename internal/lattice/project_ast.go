package lattice

import (
	"fmt"
	"sort"
	"strings"

	"github.com/RoaringBitmap/roaring"
	"github.com/agentic-research/mache/api"
)

// ProjectAST converts Formal Concepts from a flattened AST into a recursive schema.
//
// Strategy:
// 1. Identify "Container" types: Nodes that have a 'name' (identifier) and a 'body' (block).
//   - e.g. function_definition, class_definition
//
// 2. Create a Schema Node for each Container type.
// 3. Make the schema recursive: Every container can contain every other container type.
//   - This covers classes inside functions, functions inside classes, etc.
//
// 4. Default to mapping "source" -> content of the node.
func ProjectAST(concepts []Concept, ctx *FormalContext) *api.Topology {
	containerTypes := make(map[string]string) // type -> name_type (e.g. identifier, property_identifier)

	// Scan attributes to find types that have "has_name" and "has_body"
	// We look for concepts that have these attributes.
	// Actually, easier: scan the attributes themselves to find the types.
	// The context attributes look like: "type=function_definition", "has_name", "has_body"

	// Find all unique types present in the data
	types := make(map[string]bool)
	for _, attr := range ctx.Attributes {
		if attr.Name == "type" || strings.HasPrefix(attr.Name, "type=") {
			// Extract type name from "type=foo"
			t := strings.TrimPrefix(attr.Name, "type=")
			types[t] = true
		}
	}

	// For each type, check if the data supports "has_name" and "has_body"
	// We check the ctx.Stats to see if "has_name" co-occurs with "type=X".
	// But `ctx.Stats` is keyed by field path, e.g. "has_name".
	// Wait, FlattenAST produces flat records.
	// records = [{"type": "func", "has_name": true}, ...]
	//
	// We need to know: Does "type=func" implies "has_name"?
	// We can use the lattice for this!
	// Find the concept for "type=func". Check if its Intent contains "has_name".

	for t := range types {
		// Find the attribute index for "type=t"
		typeAttrIdx := -1
		for j, attr := range ctx.Attributes {
			if attr.Name == "type="+t {
				typeAttrIdx = j
				break
			}
		}
		if typeAttrIdx == -1 {
			continue
		}

		// Check if this type has a name and body
		// We look at the concept generated by this attribute
		// closure({type=t}) -> The set of all attributes that objects of this type share.
		closure := ctx.Closure(roaring.BitmapOf(uint32(typeAttrIdx)))

		hasName := false
		hasBody := false
		nameType := "identifier" // default

		iter := closure.Iterator()
		for iter.HasNext() {
			idx := iter.Next()
			attrName := ctx.Attributes[idx].Name
			if attrName == "has_name" {
				hasName = true
			}
			if strings.HasPrefix(attrName, "field_name_type=") {
				nameType = strings.TrimPrefix(attrName, "field_name_type=")
			}
			if attrName == "has_body" {
				hasBody = true
			}
		}

		if hasName && hasBody {
			containerTypes[t] = nameType
		}
	}

	// Sort types for deterministic output
	var sortedTypes []string
	for t := range containerTypes {
		sortedTypes = append(sortedTypes, t)
	}
	sort.Strings(sortedTypes)

	// Build the recursive schema
	// All containers are children of the root AND children of each other.
	var children []api.Node

	// Create a node for each container type
	for _, t := range sortedTypes {
		nameType := containerTypes[t]
		node := api.Node{
			Name:          "{{.name}}",
			Selector:      fmt.Sprintf("(%s name: (%s) @name) @scope", t, nameType),
			SkipSelfMatch: true,
			Files: []api.Leaf{
				{
					Name:            "source",
					ContentTemplate: "{{.scope}}",
				},
			},
			// Recursion will be handled by assigning the full list of children to this node
		}
		children = append(children, node)
	}

	// Assign the full list as children to each node (Recursive Structure)
	// We need to copy the slice to avoid circular reference issues if we modify it later,
	// but here we can just share the reference or copy.
	// API Node is a struct, so assignment copies the struct but slices share backing array.
	// We want the *structure* to be recursive.
	//
	// Node A -> Children [Node A, Node B]
	// Node B -> Children [Node A, Node B]

	// Since api.Node is a value type, we need to be careful.
	// We can't make an infinite struct.
	// But `children` is a slice of Nodes.
	//
	// Strategy: Create 1 level of recursion.
	// Root -> [Func, Class]
	// Func -> [Func, Class]
	// Class -> [Func, Class]
	// (Stop there to avoid infinite depth in schema JSON, although Mache engine handles it fine?
	//  Actually Mache engine handles recursion if the schema graph has cycles.
	//  But JSON marshalling of a cyclic Go struct will crash!)

	// The Mache `ingest` engine walks the schema. If the schema is a tree, it terminates.
	// If we want "Infinite recursion" (arbitrary depth), we need the schema to be a DAG or contain a self-reference.
	// JSON doesn't support references.

	// Pragmatic approach: 3 levels of nesting is enough for 99% of code.
	// Root -> [Func, Class] -> [Func, Class] -> [Func, Class]

	// Base nodes (no children yet)
	base := make([]api.Node, len(children))
	copy(base, children)

	// Depth 3 (Leaves)
	d3 := make([]api.Node, len(base))
	copy(d3, base)

	// Depth 2 (Contains d3)
	d2 := make([]api.Node, len(base))
	for i, b := range base {
		n := b
		n.Children = d3 // Assign children
		d2[i] = n
	}

	// Depth 1 (Contains d2)
	d1 := make([]api.Node, len(base))
	// This will be the root children
	for i, b := range base {
		n := b
		n.Children = d2
		d1[i] = n
	}

	return &api.Topology{
		Version: "v1",
		Nodes:   d1, // Root children
	}
}

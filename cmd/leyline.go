package cmd

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"strings"
	"time"

	"github.com/agentic-research/mache/api"
	_ "modernc.org/sqlite"
)

// materializeVirtuals adds virtual file nodes to the .db so that leyline's
// NFS mount can serve them without mache-specific runtime logic.
//
// Materialized files:
//   - _schema.json  (schema topology as JSON)
//   - PROMPT.txt    (if agentMode)
//   - callers/ dirs (from node_refs cross-references)
func materializeVirtuals(dbPath string, schema *api.Topology, agentMode bool) error {
	db, err := sql.Open("sqlite", dbPath)
	if err != nil {
		return fmt.Errorf("open db: %w", err)
	}
	defer func() { _ = db.Close() }()

	tx, err := db.Begin()
	if err != nil {
		return err
	}
	defer func() { _ = tx.Rollback() }()

	now := time.Now().UnixNano()

	// 1. _schema.json at root
	schemaJSON, err := json.MarshalIndent(schema, "", "  ")
	if err != nil {
		return fmt.Errorf("marshal schema: %w", err)
	}
	if _, err := tx.Exec(
		`INSERT OR REPLACE INTO nodes (id, parent_id, name, kind, size, mtime, record) VALUES (?, ?, ?, ?, ?, ?, ?)`,
		"_schema.json", "", "_schema.json", 0, len(schemaJSON), now, string(schemaJSON),
	); err != nil {
		return fmt.Errorf("insert _schema.json: %w", err)
	}

	// 2. PROMPT.txt if agent mode
	if agentMode {
		prompt := "# Mache Agent Mode\n\nThis mount was generated by mache for use with AI agents.\nRead source files under the function directories.\n"
		if _, err := tx.Exec(
			`INSERT OR REPLACE INTO nodes (id, parent_id, name, kind, size, mtime, record) VALUES (?, ?, ?, ?, ?, ?, ?)`,
			"PROMPT.txt", "", "PROMPT.txt", 0, len(prompt), now, prompt,
		); err != nil {
			return fmt.Errorf("insert PROMPT.txt: %w", err)
		}
	}

	// 3. Materialize callers
	if err := materializeCallers(tx, now); err != nil {
		return fmt.Errorf("materialize callers: %w", err)
	}

	return tx.Commit()
}

// materializeCallers reads node_refs and creates callers/ directory nodes
// for each function directory that has callers.
//
// For a ref (token="HandleRequest", node_id="functions/ProcessOrder/source"),
// this creates:
//   - functions/HandleRequest/callers       (dir)
//   - functions/HandleRequest/callers/ProcessOrder (file, content = node_id)
func materializeCallers(tx *sql.Tx, now int64) error {
	// Check if node_refs table exists
	var count int
	err := tx.QueryRow(`SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='node_refs'`).Scan(&count)
	if err != nil || count == 0 {
		return nil // no refs table, nothing to do
	}

	// Read all refs: token -> list of calling node IDs
	rows, err := tx.Query(`SELECT token, node_id FROM node_refs`)
	if err != nil {
		return fmt.Errorf("query node_refs: %w", err)
	}
	defer func() { _ = rows.Close() }()

	// Group by token
	callerMap := make(map[string][]string) // token -> []callerNodeID
	for rows.Next() {
		var token, nodeID string
		if err := rows.Scan(&token, &nodeID); err != nil {
			return err
		}
		callerMap[token] = append(callerMap[token], nodeID)
	}
	if err := rows.Err(); err != nil {
		return err
	}

	// For each token, find the matching directory node (via node_defs)
	// and create callers/ entries
	for token, callerNodeIDs := range callerMap {
		// Look up the directory that defines this token
		var dirID string
		err := tx.QueryRow(`SELECT dir_id FROM node_defs WHERE token = ?`, token).Scan(&dirID)
		if err != nil {
			continue // no definition found, skip
		}

		// Create callers/ directory under the defining dir
		callersID := dirID + "/callers"

		// Check if callers/ dir already exists
		var exists int
		_ = tx.QueryRow(`SELECT COUNT(*) FROM nodes WHERE id = ?`, callersID).Scan(&exists)
		if exists == 0 {
			if _, err := tx.Exec(
				`INSERT INTO nodes (id, parent_id, name, kind, size, mtime, record) VALUES (?, ?, ?, ?, ?, ?, ?)`,
				callersID, dirID, "callers", 1, 0, now, nil,
			); err != nil {
				return fmt.Errorf("insert callers dir %s: %w", callersID, err)
			}
		}

		// Create an entry for each caller
		for _, callerNodeID := range callerNodeIDs {
			// Extract the caller's function name from the node_id path
			// e.g. "functions/ProcessOrder/source" -> "ProcessOrder"
			callerName := extractFuncName(callerNodeID)
			if callerName == "" {
				continue
			}

			entryID := callersID + "/" + callerName
			// Check if entry already exists
			var entryExists int
			_ = tx.QueryRow(`SELECT COUNT(*) FROM nodes WHERE id = ?`, entryID).Scan(&entryExists)
			if entryExists > 0 {
				continue
			}

			content := callerNodeID // content points to the calling node
			if _, err := tx.Exec(
				`INSERT INTO nodes (id, parent_id, name, kind, size, mtime, record) VALUES (?, ?, ?, ?, ?, ?, ?)`,
				entryID, callersID, callerName, 0, len(content), now, content,
			); err != nil {
				return fmt.Errorf("insert caller entry %s: %w", entryID, err)
			}
		}
	}

	return nil
}

// extractFuncName pulls the function name from a node path like "functions/Foo/source".
// Returns the second-to-last path component (the function directory name).
func extractFuncName(nodeID string) string {
	// "functions/ProcessOrder/source" -> "ProcessOrder"
	// "types/MyStruct/source" -> "MyStruct"
	parts := strings.Split(nodeID, "/")
	if len(parts) < 2 {
		return ""
	}
	return parts[len(parts)-2]
}

// copyFile copies src to dst, creating dst if it doesn't exist.
func copyFile(src, dst string) error {
	in, err := os.Open(src)
	if err != nil {
		return err
	}
	defer func() { _ = in.Close() }()

	out, err := os.Create(dst)
	if err != nil {
		return err
	}

	if _, err := io.Copy(out, in); err != nil {
		_ = out.Close()
		return err
	}
	return out.Close()
}
